// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'apple_pay_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ApplePayEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() link,
    required TResult Function() initialize,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? link,
    TResult? Function()? initialize,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? link,
    TResult Function()? initialize,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Link value) link,
    required TResult Function(_Initialize value) initialize,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Link value)? link,
    TResult? Function(_Initialize value)? initialize,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Link value)? link,
    TResult Function(_Initialize value)? initialize,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApplePayEventCopyWith<$Res> {
  factory $ApplePayEventCopyWith(
          ApplePayEvent value, $Res Function(ApplePayEvent) then) =
      _$ApplePayEventCopyWithImpl<$Res, ApplePayEvent>;
}

/// @nodoc
class _$ApplePayEventCopyWithImpl<$Res, $Val extends ApplePayEvent>
    implements $ApplePayEventCopyWith<$Res> {
  _$ApplePayEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_LinkCopyWith<$Res> {
  factory _$$_LinkCopyWith(_$_Link value, $Res Function(_$_Link) then) =
      __$$_LinkCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LinkCopyWithImpl<$Res>
    extends _$ApplePayEventCopyWithImpl<$Res, _$_Link>
    implements _$$_LinkCopyWith<$Res> {
  __$$_LinkCopyWithImpl(_$_Link _value, $Res Function(_$_Link) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Link implements _Link {
  const _$_Link();

  @override
  String toString() {
    return 'ApplePayEvent.link()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Link);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() link,
    required TResult Function() initialize,
  }) {
    return link();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? link,
    TResult? Function()? initialize,
  }) {
    return link?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? link,
    TResult Function()? initialize,
    required TResult orElse(),
  }) {
    if (link != null) {
      return link();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Link value) link,
    required TResult Function(_Initialize value) initialize,
  }) {
    return link(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Link value)? link,
    TResult? Function(_Initialize value)? initialize,
  }) {
    return link?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Link value)? link,
    TResult Function(_Initialize value)? initialize,
    required TResult orElse(),
  }) {
    if (link != null) {
      return link(this);
    }
    return orElse();
  }
}

abstract class _Link implements ApplePayEvent {
  const factory _Link() = _$_Link;
}

/// @nodoc
abstract class _$$_InitializeCopyWith<$Res> {
  factory _$$_InitializeCopyWith(
          _$_Initialize value, $Res Function(_$_Initialize) then) =
      __$$_InitializeCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_InitializeCopyWithImpl<$Res>
    extends _$ApplePayEventCopyWithImpl<$Res, _$_Initialize>
    implements _$$_InitializeCopyWith<$Res> {
  __$$_InitializeCopyWithImpl(
      _$_Initialize _value, $Res Function(_$_Initialize) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Initialize implements _Initialize {
  const _$_Initialize();

  @override
  String toString() {
    return 'ApplePayEvent.initialize()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Initialize);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() link,
    required TResult Function() initialize,
  }) {
    return initialize();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? link,
    TResult? Function()? initialize,
  }) {
    return initialize?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? link,
    TResult Function()? initialize,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Link value) link,
    required TResult Function(_Initialize value) initialize,
  }) {
    return initialize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Link value)? link,
    TResult? Function(_Initialize value)? initialize,
  }) {
    return initialize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Link value)? link,
    TResult Function(_Initialize value)? initialize,
    required TResult orElse(),
  }) {
    if (initialize != null) {
      return initialize(this);
    }
    return orElse();
  }
}

abstract class _Initialize implements ApplePayEvent {
  const factory _Initialize() = _$_Initialize;
}

/// @nodoc
mixin _$ApplePayState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(LinkPaymentMethodFailure failure) failed,
    required TResult Function() platformNotSupported,
    required TResult Function() alreadyLinked,
    required TResult Function() notLinked,
    required TResult Function() success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(LinkPaymentMethodFailure failure)? failed,
    TResult? Function()? platformNotSupported,
    TResult? Function()? alreadyLinked,
    TResult? Function()? notLinked,
    TResult? Function()? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(LinkPaymentMethodFailure failure)? failed,
    TResult Function()? platformNotSupported,
    TResult Function()? alreadyLinked,
    TResult Function()? notLinked,
    TResult Function()? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Failed value) failed,
    required TResult Function(_PlatformNotSupported value) platformNotSupported,
    required TResult Function(_AlreadyLinked value) alreadyLinked,
    required TResult Function(_NotLinked value) notLinked,
    required TResult Function(_Success value) success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Failed value)? failed,
    TResult? Function(_PlatformNotSupported value)? platformNotSupported,
    TResult? Function(_AlreadyLinked value)? alreadyLinked,
    TResult? Function(_NotLinked value)? notLinked,
    TResult? Function(_Success value)? success,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Failed value)? failed,
    TResult Function(_PlatformNotSupported value)? platformNotSupported,
    TResult Function(_AlreadyLinked value)? alreadyLinked,
    TResult Function(_NotLinked value)? notLinked,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ApplePayStateCopyWith<$Res> {
  factory $ApplePayStateCopyWith(
          ApplePayState value, $Res Function(ApplePayState) then) =
      _$ApplePayStateCopyWithImpl<$Res, ApplePayState>;
}

/// @nodoc
class _$ApplePayStateCopyWithImpl<$Res, $Val extends ApplePayState>
    implements $ApplePayStateCopyWith<$Res> {
  _$ApplePayStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_LoadingCopyWith<$Res> {
  factory _$$_LoadingCopyWith(
          _$_Loading value, $Res Function(_$_Loading) then) =
      __$$_LoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_LoadingCopyWithImpl<$Res>
    extends _$ApplePayStateCopyWithImpl<$Res, _$_Loading>
    implements _$$_LoadingCopyWith<$Res> {
  __$$_LoadingCopyWithImpl(_$_Loading _value, $Res Function(_$_Loading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Loading extends _Loading {
  const _$_Loading() : super._();

  @override
  String toString() {
    return 'ApplePayState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Loading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(LinkPaymentMethodFailure failure) failed,
    required TResult Function() platformNotSupported,
    required TResult Function() alreadyLinked,
    required TResult Function() notLinked,
    required TResult Function() success,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(LinkPaymentMethodFailure failure)? failed,
    TResult? Function()? platformNotSupported,
    TResult? Function()? alreadyLinked,
    TResult? Function()? notLinked,
    TResult? Function()? success,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(LinkPaymentMethodFailure failure)? failed,
    TResult Function()? platformNotSupported,
    TResult Function()? alreadyLinked,
    TResult Function()? notLinked,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Failed value) failed,
    required TResult Function(_PlatformNotSupported value) platformNotSupported,
    required TResult Function(_AlreadyLinked value) alreadyLinked,
    required TResult Function(_NotLinked value) notLinked,
    required TResult Function(_Success value) success,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Failed value)? failed,
    TResult? Function(_PlatformNotSupported value)? platformNotSupported,
    TResult? Function(_AlreadyLinked value)? alreadyLinked,
    TResult? Function(_NotLinked value)? notLinked,
    TResult? Function(_Success value)? success,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Failed value)? failed,
    TResult Function(_PlatformNotSupported value)? platformNotSupported,
    TResult Function(_AlreadyLinked value)? alreadyLinked,
    TResult Function(_NotLinked value)? notLinked,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading extends ApplePayState {
  const factory _Loading() = _$_Loading;
  const _Loading._() : super._();
}

/// @nodoc
abstract class _$$_FailedCopyWith<$Res> {
  factory _$$_FailedCopyWith(_$_Failed value, $Res Function(_$_Failed) then) =
      __$$_FailedCopyWithImpl<$Res>;
  @useResult
  $Res call({LinkPaymentMethodFailure failure});
}

/// @nodoc
class __$$_FailedCopyWithImpl<$Res>
    extends _$ApplePayStateCopyWithImpl<$Res, _$_Failed>
    implements _$$_FailedCopyWith<$Res> {
  __$$_FailedCopyWithImpl(_$_Failed _value, $Res Function(_$_Failed) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? failure = null,
  }) {
    return _then(_$_Failed(
      null == failure
          ? _value.failure
          : failure // ignore: cast_nullable_to_non_nullable
              as LinkPaymentMethodFailure,
    ));
  }
}

/// @nodoc

class _$_Failed extends _Failed {
  const _$_Failed(this.failure) : super._();

  @override
  final LinkPaymentMethodFailure failure;

  @override
  String toString() {
    return 'ApplePayState.failed(failure: $failure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Failed &&
            const DeepCollectionEquality().equals(other.failure, failure));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(failure));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_FailedCopyWith<_$_Failed> get copyWith =>
      __$$_FailedCopyWithImpl<_$_Failed>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(LinkPaymentMethodFailure failure) failed,
    required TResult Function() platformNotSupported,
    required TResult Function() alreadyLinked,
    required TResult Function() notLinked,
    required TResult Function() success,
  }) {
    return failed(failure);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(LinkPaymentMethodFailure failure)? failed,
    TResult? Function()? platformNotSupported,
    TResult? Function()? alreadyLinked,
    TResult? Function()? notLinked,
    TResult? Function()? success,
  }) {
    return failed?.call(failure);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(LinkPaymentMethodFailure failure)? failed,
    TResult Function()? platformNotSupported,
    TResult Function()? alreadyLinked,
    TResult Function()? notLinked,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(failure);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Failed value) failed,
    required TResult Function(_PlatformNotSupported value) platformNotSupported,
    required TResult Function(_AlreadyLinked value) alreadyLinked,
    required TResult Function(_NotLinked value) notLinked,
    required TResult Function(_Success value) success,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Failed value)? failed,
    TResult? Function(_PlatformNotSupported value)? platformNotSupported,
    TResult? Function(_AlreadyLinked value)? alreadyLinked,
    TResult? Function(_NotLinked value)? notLinked,
    TResult? Function(_Success value)? success,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Failed value)? failed,
    TResult Function(_PlatformNotSupported value)? platformNotSupported,
    TResult Function(_AlreadyLinked value)? alreadyLinked,
    TResult Function(_NotLinked value)? notLinked,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class _Failed extends ApplePayState {
  const factory _Failed(final LinkPaymentMethodFailure failure) = _$_Failed;
  const _Failed._() : super._();

  LinkPaymentMethodFailure get failure;
  @JsonKey(ignore: true)
  _$$_FailedCopyWith<_$_Failed> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_PlatformNotSupportedCopyWith<$Res> {
  factory _$$_PlatformNotSupportedCopyWith(_$_PlatformNotSupported value,
          $Res Function(_$_PlatformNotSupported) then) =
      __$$_PlatformNotSupportedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_PlatformNotSupportedCopyWithImpl<$Res>
    extends _$ApplePayStateCopyWithImpl<$Res, _$_PlatformNotSupported>
    implements _$$_PlatformNotSupportedCopyWith<$Res> {
  __$$_PlatformNotSupportedCopyWithImpl(_$_PlatformNotSupported _value,
      $Res Function(_$_PlatformNotSupported) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_PlatformNotSupported extends _PlatformNotSupported {
  const _$_PlatformNotSupported() : super._();

  @override
  String toString() {
    return 'ApplePayState.platformNotSupported()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_PlatformNotSupported);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(LinkPaymentMethodFailure failure) failed,
    required TResult Function() platformNotSupported,
    required TResult Function() alreadyLinked,
    required TResult Function() notLinked,
    required TResult Function() success,
  }) {
    return platformNotSupported();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(LinkPaymentMethodFailure failure)? failed,
    TResult? Function()? platformNotSupported,
    TResult? Function()? alreadyLinked,
    TResult? Function()? notLinked,
    TResult? Function()? success,
  }) {
    return platformNotSupported?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(LinkPaymentMethodFailure failure)? failed,
    TResult Function()? platformNotSupported,
    TResult Function()? alreadyLinked,
    TResult Function()? notLinked,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (platformNotSupported != null) {
      return platformNotSupported();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Failed value) failed,
    required TResult Function(_PlatformNotSupported value) platformNotSupported,
    required TResult Function(_AlreadyLinked value) alreadyLinked,
    required TResult Function(_NotLinked value) notLinked,
    required TResult Function(_Success value) success,
  }) {
    return platformNotSupported(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Failed value)? failed,
    TResult? Function(_PlatformNotSupported value)? platformNotSupported,
    TResult? Function(_AlreadyLinked value)? alreadyLinked,
    TResult? Function(_NotLinked value)? notLinked,
    TResult? Function(_Success value)? success,
  }) {
    return platformNotSupported?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Failed value)? failed,
    TResult Function(_PlatformNotSupported value)? platformNotSupported,
    TResult Function(_AlreadyLinked value)? alreadyLinked,
    TResult Function(_NotLinked value)? notLinked,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (platformNotSupported != null) {
      return platformNotSupported(this);
    }
    return orElse();
  }
}

abstract class _PlatformNotSupported extends ApplePayState {
  const factory _PlatformNotSupported() = _$_PlatformNotSupported;
  const _PlatformNotSupported._() : super._();
}

/// @nodoc
abstract class _$$_AlreadyLinkedCopyWith<$Res> {
  factory _$$_AlreadyLinkedCopyWith(
          _$_AlreadyLinked value, $Res Function(_$_AlreadyLinked) then) =
      __$$_AlreadyLinkedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AlreadyLinkedCopyWithImpl<$Res>
    extends _$ApplePayStateCopyWithImpl<$Res, _$_AlreadyLinked>
    implements _$$_AlreadyLinkedCopyWith<$Res> {
  __$$_AlreadyLinkedCopyWithImpl(
      _$_AlreadyLinked _value, $Res Function(_$_AlreadyLinked) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_AlreadyLinked extends _AlreadyLinked {
  const _$_AlreadyLinked() : super._();

  @override
  String toString() {
    return 'ApplePayState.alreadyLinked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AlreadyLinked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(LinkPaymentMethodFailure failure) failed,
    required TResult Function() platformNotSupported,
    required TResult Function() alreadyLinked,
    required TResult Function() notLinked,
    required TResult Function() success,
  }) {
    return alreadyLinked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(LinkPaymentMethodFailure failure)? failed,
    TResult? Function()? platformNotSupported,
    TResult? Function()? alreadyLinked,
    TResult? Function()? notLinked,
    TResult? Function()? success,
  }) {
    return alreadyLinked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(LinkPaymentMethodFailure failure)? failed,
    TResult Function()? platformNotSupported,
    TResult Function()? alreadyLinked,
    TResult Function()? notLinked,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (alreadyLinked != null) {
      return alreadyLinked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Failed value) failed,
    required TResult Function(_PlatformNotSupported value) platformNotSupported,
    required TResult Function(_AlreadyLinked value) alreadyLinked,
    required TResult Function(_NotLinked value) notLinked,
    required TResult Function(_Success value) success,
  }) {
    return alreadyLinked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Failed value)? failed,
    TResult? Function(_PlatformNotSupported value)? platformNotSupported,
    TResult? Function(_AlreadyLinked value)? alreadyLinked,
    TResult? Function(_NotLinked value)? notLinked,
    TResult? Function(_Success value)? success,
  }) {
    return alreadyLinked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Failed value)? failed,
    TResult Function(_PlatformNotSupported value)? platformNotSupported,
    TResult Function(_AlreadyLinked value)? alreadyLinked,
    TResult Function(_NotLinked value)? notLinked,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (alreadyLinked != null) {
      return alreadyLinked(this);
    }
    return orElse();
  }
}

abstract class _AlreadyLinked extends ApplePayState {
  const factory _AlreadyLinked() = _$_AlreadyLinked;
  const _AlreadyLinked._() : super._();
}

/// @nodoc
abstract class _$$_NotLinkedCopyWith<$Res> {
  factory _$$_NotLinkedCopyWith(
          _$_NotLinked value, $Res Function(_$_NotLinked) then) =
      __$$_NotLinkedCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_NotLinkedCopyWithImpl<$Res>
    extends _$ApplePayStateCopyWithImpl<$Res, _$_NotLinked>
    implements _$$_NotLinkedCopyWith<$Res> {
  __$$_NotLinkedCopyWithImpl(
      _$_NotLinked _value, $Res Function(_$_NotLinked) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_NotLinked extends _NotLinked {
  const _$_NotLinked() : super._();

  @override
  String toString() {
    return 'ApplePayState.notLinked()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_NotLinked);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(LinkPaymentMethodFailure failure) failed,
    required TResult Function() platformNotSupported,
    required TResult Function() alreadyLinked,
    required TResult Function() notLinked,
    required TResult Function() success,
  }) {
    return notLinked();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(LinkPaymentMethodFailure failure)? failed,
    TResult? Function()? platformNotSupported,
    TResult? Function()? alreadyLinked,
    TResult? Function()? notLinked,
    TResult? Function()? success,
  }) {
    return notLinked?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(LinkPaymentMethodFailure failure)? failed,
    TResult Function()? platformNotSupported,
    TResult Function()? alreadyLinked,
    TResult Function()? notLinked,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (notLinked != null) {
      return notLinked();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Failed value) failed,
    required TResult Function(_PlatformNotSupported value) platformNotSupported,
    required TResult Function(_AlreadyLinked value) alreadyLinked,
    required TResult Function(_NotLinked value) notLinked,
    required TResult Function(_Success value) success,
  }) {
    return notLinked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Failed value)? failed,
    TResult? Function(_PlatformNotSupported value)? platformNotSupported,
    TResult? Function(_AlreadyLinked value)? alreadyLinked,
    TResult? Function(_NotLinked value)? notLinked,
    TResult? Function(_Success value)? success,
  }) {
    return notLinked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Failed value)? failed,
    TResult Function(_PlatformNotSupported value)? platformNotSupported,
    TResult Function(_AlreadyLinked value)? alreadyLinked,
    TResult Function(_NotLinked value)? notLinked,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (notLinked != null) {
      return notLinked(this);
    }
    return orElse();
  }
}

abstract class _NotLinked extends ApplePayState {
  const factory _NotLinked() = _$_NotLinked;
  const _NotLinked._() : super._();
}

/// @nodoc
abstract class _$$_SuccessCopyWith<$Res> {
  factory _$$_SuccessCopyWith(
          _$_Success value, $Res Function(_$_Success) then) =
      __$$_SuccessCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_SuccessCopyWithImpl<$Res>
    extends _$ApplePayStateCopyWithImpl<$Res, _$_Success>
    implements _$$_SuccessCopyWith<$Res> {
  __$$_SuccessCopyWithImpl(_$_Success _value, $Res Function(_$_Success) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_Success extends _Success {
  const _$_Success() : super._();

  @override
  String toString() {
    return 'ApplePayState.success()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_Success);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(LinkPaymentMethodFailure failure) failed,
    required TResult Function() platformNotSupported,
    required TResult Function() alreadyLinked,
    required TResult Function() notLinked,
    required TResult Function() success,
  }) {
    return success();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(LinkPaymentMethodFailure failure)? failed,
    TResult? Function()? platformNotSupported,
    TResult? Function()? alreadyLinked,
    TResult? Function()? notLinked,
    TResult? Function()? success,
  }) {
    return success?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(LinkPaymentMethodFailure failure)? failed,
    TResult Function()? platformNotSupported,
    TResult Function()? alreadyLinked,
    TResult Function()? notLinked,
    TResult Function()? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Failed value) failed,
    required TResult Function(_PlatformNotSupported value) platformNotSupported,
    required TResult Function(_AlreadyLinked value) alreadyLinked,
    required TResult Function(_NotLinked value) notLinked,
    required TResult Function(_Success value) success,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Failed value)? failed,
    TResult? Function(_PlatformNotSupported value)? platformNotSupported,
    TResult? Function(_AlreadyLinked value)? alreadyLinked,
    TResult? Function(_NotLinked value)? notLinked,
    TResult? Function(_Success value)? success,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Failed value)? failed,
    TResult Function(_PlatformNotSupported value)? platformNotSupported,
    TResult Function(_AlreadyLinked value)? alreadyLinked,
    TResult Function(_NotLinked value)? notLinked,
    TResult Function(_Success value)? success,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _Success extends ApplePayState {
  const factory _Success() = _$_Success;
  const _Success._() : super._();
}
